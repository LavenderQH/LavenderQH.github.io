{"posts":[{"title":"C语言学习笔记（一）","text":"前言我大学本科从经管专业转到软件工程专业，大一的时候没有学过任何计算机方面的课程，大二学的专业课直接就是数据库、web开发等课程，周围的同学都已经在大一学过Java的面向对象等内容，当时为了跟上进度自己自学了Java、python的内容，并且学习的节奏很快，一直把读写代码作为学习目标，这导致我的基础十分不牢固，对于一些底层原理一知半解，后面一直在卷绩点、保研、在实验室打工，现在已经快到研二开学，我打算将自己所学的技术栈，系统的梳理一遍，查漏补缺，并且将学习过程形成的笔记发布在个人博客中，以督促自己学习和整理。我一直认为C语言是一门必须学习的计算机编程语言，在保研夏令营准备期间，考虑到部分学校算法机试可能只能用C++,因此看了《算法笔记》一书，在这本书中学了部分C语言基础，但是当时也只是为了应付机试，对于C语言的学习也不够系统，那么我的个人笔记就从C语言开始。 参考资料阮一峰老师的C语言入门教程 https://wangdoc.com/clang/GCC编译过程和原理浅析 https://www.jianshu.com/p/15d8b22ae56a 1、C语言简介1969年，美国贝尔实验室的肯·汤普森（Ken Thompson）与丹尼斯·里奇（Dennis Ritchie）一起开发了 Unix 操作系统。Unix 是用汇编语言写的，无法移植到其他计算机，他们决定使用高级语言重写。但当时的高级语言无法满足要求，汤普森在 BCPL 语言的基础上发明了 B 语言。1972年，丹尼斯·里奇和布莱恩·柯林汉（Brian Kernighan）又在 B 语言的基础上重新设计了一种新语言，取代 B 语言，称为 C 语言。1973年，整个 Unix 系统都使用 C 语言重写。1988年，美国国家标准协会（ANSI）正式将 C 语言标准化，标志着 C 语言开始稳定和规范化。 1.1 C语言特征低级语言C语言能够直接操作硬件、管理内存、与操作系统对话，是一种接近底层的低级语言，适合写需要和硬件交互、有极高性能要求的程序。 可移植性C语言可以相对简单的移植到各种硬件架构和操作系统，也是嵌入式系统的首选语言，具有良好可移植性。 简单性语法相对简单，语法规则不多，都是基础语法，不提供高级数据结构。 灵活性有很高的编程自由，程序员自己管理内存，也不提供类型检查、数组负索引检查、指针位置检查等措施，也使得debug不太容易。 1.2 C语言版本K＆R CC语言原始版本。 ANSI C（又称 C89 或 C90）1989年，美国国家标准协会（ANSI）制定的 C 语言标准。 C951995年对C89补充的版本 C991999年，C语言标准的第一次大型修订版本，是目前最流行的C语言版本。 C112011年，对C语言的又一次修订版本。 C172017年，C11标准的修补版本 1.3 C语言的编译C语言源码是文本文件，需要通过编译器，生成可执行文件执行，最为常见的C语言编译器是GCC，下面简单说明一下GCC编译器工作过程。1、预处理（Pre-Processing）：主要包括宏定义、文件包含、条件编译三部分，预处理过程读入源代码、删除程序中的注释和多余空白字符、检查包含预处理指令的语句和宏定义，并对其进行响应和替换，最后生成.i 文件。2、编译器（Compiling）：将预处理完毕的.i文件进行语法分析，优化后生成汇编代码，生成.s文件。3、汇编器（Assembling）：将.s汇编程序汇编为机器语言或指令，生成.o文件。4、链接器（Linking）：链接器链接程序运行所需的目标文件，以及依赖的库文件，最后生成可执行文件。 2、C语言语法2.1 基础语法语句C语言语句必须使用;结尾，一个语句可以写在同一行也可以随意拆分成多行，依靠分号判断语句的结束。 表达式C语言的计算通过表达式来完成，表达式不构成语句，被包含在语句中，表达式都有返回值，语句不一定。 语句块C语言通过一对{}将多个语句组成语句块，大括号结尾不需要添加分号。 空格C语言中的空格主要用来帮助编译器区分语法单位和增加代码可读性。 注释注释用于解释说明代码，C语言中有两种注释方式 12345/* 块注释（block comment）可内部分行可插在行内*/ 1//行注释（line comment），只能用在单行 标准库程序中需要的功能不一定需要自己编写，C语言中自带了一些功能，统称为“标准库”，这些标准库定义在不同的文件中，这些文件称为“头文件”，后缀为.h，如果想要使用某个标准库功能，需要通过#include命令来加载对应头文件,如 1#include &lt;stdio.h&gt; //加载stdio.h头文件，加载头文件的语句不需要&quot;;&quot;结尾 变量变量（variable）可理解为一块内存区域中的名字，通过变量名，引用这块内存区域，获取里面存储的值，由于值可变，因此称为变量 变量名C语言变量命名规则：只能由字母、数字和下划线组成；不能以数字开头；长度不超过63个字符。注意：C语言除了关键字不能用外，，两个下划线开头的变量名，以及一个下划线 + 大写英文字母开头的变量名，都是系统保留的，也不建议使用，变量名区分大小写。 变量声明与赋值C语言变量必须先声明后使用，声明变量时要声明变量类型。在变量声明时就会分配内存空间，但是不会清除内存里面原来的值，此时的变量是一个随机的值，之后需要进行赋值，通过=进行赋值，可以声明和赋值同时进行，也可以先声明后赋值。注意：作用域（scope）指变量的生效范围，主要有两种，文件作用域（file scope）即源码文件顶层声明的变量，整个文件中都有效;块作用域（block scope）即代码块中声明的变量，只在声明的代码块中有效。 运算符C语言一共有50多种运算符。 算术运算符123456+ //表示正值或者加法- //表示负值或者减法* //表示乘法/ //表示除法 这里注意计算机中两个整数相除结果还是整数% //表示取余 这里注意余值的正负和第一个运算数一致//算术运算符号可以和赋值运算符号结合，表示对自身的值进行运算，如：+=、-=、*=、/=、%= 自运算符123++ //自增运算符-- //自减运算符//注意自运算符在变量前后的结果不同，在变量前表示先执行自运算，再返回变量的值，放在之后表示先返回变量的值再执行自运算 关系运算符1234567//用于表示比较的运算符号，共6个&gt; //大于&lt; //小于&gt;= //大于等于&lt;= //小于等于== //等于!= //不等于 逻辑运算符123! //否运算&amp;&amp; //与运算|| //或运算 位运算符123456~ //取反运算符，将每个二级制位，0变1，1变0&amp; //与运算符，将每个二进制位进行比较，返回新值| //或运算符，将每个二级制位进行比较，返回新值^ //异或运算符，将每个二级制位进行比较，返回新值&lt;&lt; //左移运算符，二进制每位向左移指定位数，尾部补零&gt;&gt; //右移运算符，二进制每位向右移动指定位数，头部补零 逗号运算符,是一个用于连接表达式的运算符号 运算符优先级12//部分常见优先级顺序圆括号（()）&gt;自增自减运算（--++）—&gt;一元运算（+-正负）&gt;乘除法（*/）&gt;加减法（+-）&gt;关系运算（&gt;&lt;）&gt;赋值运算（=） printf()printf()使用方式如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt; //printf()在头文件stdio.h中定义，因此使用前必须在源码文件头部通过include引入。int main(void){ printf(&quot;Hello World\\n&quot;);//基础使用方式，输出文本Hello World到屏幕并换行 printf(&quot;There are %i apples\\n&quot;, 3);//使用占位符，输出的文本为There are 3 apples /* 常用占位符 %a：十六进制浮点数，字母输出为小写。 %A：十六进制浮点数，字母输出为大写。 %c：字符。 %d：十进制整数。 %e：使用科学计数法的浮点数，指数部分的e为小写。 %E：使用科学计数法的浮点数，指数部分的E为大写。 %i：整数，基本等同于%d。 %f：小数（包含float类型和double类型）。 %g：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的e为小写。 %G：等同于%g，唯一的区别是指数部分的E为大写。 %hd：十进制 short int 类型。 %ho：八进制 short int 类型。 %hx：十六进制 short int 类型。 %hu：unsigned short int 类型。 %ld：十进制 long int 类型。 %lo：八进制 long int 类型。 %lx：十六进制 long int 类型。 %lu：unsigned long int 类型。 %lld：十进制 long long int 类型。 %llo：八进制 long long int 类型。 %llx：十六进制 long long int 类型。 %llu：unsigned long long int 类型。 %Le：科学计数法表示的 long double 类型浮点数。 %Lf：long double 类型浮点数。 %n：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。 %o：八进制整数。 %p：指针。 %s：字符串。 %u：无符号整数（unsigned int）。 %x：十六进制整数。 %zd：size_t类型。 %%：输出一个百分号。 */ printf(&quot;%5d\\n&quot;, 123);//限定占位符宽度 printf(&quot;%+d\\n&quot;, 12);//显示正数的+号 printf(&quot;Number is %.2f\\n&quot;, 0.5);//限定小数位数，可以和限定宽度一起使用 printf(&quot;%.5s\\n&quot;, &quot;hello world&quot;);//输出部分字符} 流程控制if条件语句条件判断，如果expression为真则执行statement，有下面三种使用方式，此外还可以嵌套使用 1234567891011121314151617if (expression) { statement; //C语言语法是可以不加{}的，为了便于阅读和避免错误，建议是在一个语句时不加，多个语句时加，我个人的代码习惯是都加{}。}if (expression) { statement;}else { statement;}if (expression) { statement;}else if (expression) { statement;}else { statement;} 三元运算符三元运算符，如果expression为真，执行statement1，否则执行statement2 1&lt;expression&gt; ? &lt;statement1&gt; : &lt;statement2&gt;//和if else效果相同，但是注意三元运算符时表达式，而if else是语句， switch语句1234567891011switch (expression) { case value1: statement; break; case value2: statement; break; default: statement;}//case后面可以不加break，这样执行完一个case继续执行下一个 while语句123while (expression){ statement;}//当while中单个语句时可以不加{} do…while语句123do { statement;} while (expression);//单个语句可以不加{} for语句123for (initialization; continuation; action) { statement;}//initialization初始化表达式，continuation判断表达式，action循环变量处理表达式，单个语句可以不加{} break语句1234567//break命令可用来跳出循环体和switch结构，以for循环为例for (int i = 0; i &lt; 10; i++){ printf(&quot;%d&quot;,i); if (i == 6){ break; }}//上述循环会输出0~6 continue语句continue命令用于在循环体内部终止本轮循环进入下一轮循环 123456789int i = 0;while (i &lt; 10) { if (i == 6) { i++; continue; } printf(&quot;%d&quot;,i); i++;}//上述循环会输出0~5,7~9 goto语句goto语句用于跳到指定标签名，会破坏结构化编程，建议不要轻易使用，一个主要的用法是用来跳出多层循环，需要配合标签使用 123456int i = 0;labelName: printf(&quot;%d&quot;,i);if (i == 0) { goto labelName;}//代码会一直输出0 数据类型C语言有三种基本数据类型分别是字符(char)、整数(int)和浮点数(float)。 字符类型字符类型使用char关键字声明，注意C语言规定字符常量必须放在单引号中 1char ch = 'A';//如果要表示单引号这个字符通过\\来转义如'\\'' 计算机内部，字符类型使用一个字节（8比特位）存储，C语言将其当作整数处理，所以字符类型就是宽度为一个字节的整数，在字符类型中整数和字符是可以互换的，具体由ASCII码确定。 1234567891011//转义用来表示ASCII码定义的一些无法打印的控制字符,常见有以下转义字符\\a //警报\\b //退格键，光标回退一个字符\\f //换页符，光标移动到下一页\\n //换行符\\r //回车符，光标移动到同一行的开头\\t //制表符，光标移动到下一个水平制表位。通常是下一个8的倍数\\v //垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列\\0 //null 字符，代表没有内容\\nn //字符的八进制写法\\xnn //字符的十六进制写法 整数类型整数类型通过int关键字声明，占用4个字节（常见）或8个字节 1signed int a; C语言中有signed和unsigned关键字用来表示一个类型是否带有正负号，int类型默认是带有正负号的，因此可以省略signed，如果要表示非负整数可以通过使用unsigned来增加能表示的整数最大值，注意char类型默认是否带有正负号由系统决定。 123short a;//int的子类型，通常占用2个字节long b;//int的子类型，占用字节不少于int，至少4个字节long long c;//int的子类型，占用空间多余long，至少为8个字节 C语言的整数默认是十进制数，如果要表示八进制数使用0作为前缀，表示十六进制使用0x或0X作为前缀 123456789int a = 012 //八进制等于十进制的10int a = 0x12 //十六进制等于十进制18//与整数进制相关的占位符%d //十进制整数%o //八进制整数%x //十六进制整数%#o //显示前缀0的八进制整数%#x //显示前缀0x的十六进制整数%#X //显示前缀0X的十六进制整数 浮点数类型任何由小数点的数值，都会被编译器解释位浮点数，浮点数是用指数的形式存储一个数值，浮点数类型用float关键字声明，占用4个字节，其中8位存放指数的值和符号，剩下24位存放小数的值和符号，至少提供6位有效数字。 1234float fl = 3.14;double d; //占用8个字节，至少提供13位有效数字long double ld; //占用16个字节double d = 123.456e3; //可以使用科学计数法来表示浮点数 注意由于存在精度限制，浮点数只是一个近似值，他的计算不是精确的。 布尔类型C语言没有为布尔值单独设置类型，而是用0表示伪，非零数表示真。在C99中添加了_Bool表示布尔值，但是还是用0表示伪，用1表示真。头文件stdbool.h定义了bool,并且定义true代表1，false代表0。 12#include &lt;stdbool.h&gt;bool flag = false; 字面量字面量是代码中直接出现的值，编译时，字面量也会写入内存，因此编译器需要为字面量指定数据类型。整数一般被指定为int类型，超出int则被指定为long int，超出long int则会被指定为unsigned long，后续还有long long，unsigned long long。小数会被指定为double类型可以在字面量后加后缀将其指定为一个不同的类型 12345//常用字面量后缀f和F //float类型l和L //对于整数是long int，对于浮点数是long doublell和LL //Long Long类型u和U //unsigned int类型 溢出每种数据类型都有数值范围，存放数值超出这个范围就会溢出，超出最大值，为向上溢出，超出最小值为向下溢出，编译器对于溢出一般不错报错，而是正常执行代码，忽略多出的二进制位，这会导致各种问题，因此应该要避免溢出。 123456789//避免溢出最好的方法是将运算结果与类型的极限值做比较int a;int sum;if (sum &gt; INT_MAX - a) { sum.tobigertype(); sum = sum + a;}else { sum = sum + a;} sizeof运算符sizeof()是C语言的一个运算符，用于返回数据类型或值占用的字节数，参数可以是某个类型也可以是某个值。关于sizeof()的返回值类型C语言只规定是无符号整数，没有规定具体的类型，在头文件stddef.h（引入stdio.h时会自动引入）中定义了size_t表示sizeof的返回值类型。 123int a = sizeof(int);int b = sizeof(a);printf(&quot;%zd&quot;,sizeof(b));//有专门的占位符%zd或者%zu，无论sizeof返回值是什么都可以正常输出，若系统不支持，可以使用%u或%lu 类型转化自动类型转换：某些情况下C语言会自动转化某个值的类型 赋值运算：在进行赋值运算时C语言会自动将右边的值转成左边变量的类型。 浮点数赋值整数：会直接丢弃浮点数的小数部分。 整数赋值浮点数：会自动转换为浮点数。 窄类型赋值宽类型：类型提升。 宽类型赋值窄类型：类型降级，系统自动截去多余二进制位。 混合类型运算：不同类型值混合运算时会先转成同一类型再计算。 浮点数与整数：整数先转成浮点数再计算。 不同浮点数：宽度较小的类型先转成宽度较大的类型。 不同整数：宽度较小的类型先转成宽度较大的类型。（注意点：1、避免无符号整数和有符号整数的混合运算，这时会将有符号整数转成无符号整数再计算；2、宽度小于int的类型结果会自动提升为int。） 函数：函数的参数和返回值会自动转成函数定义的类型。 显示类型转换：C语言运行进行显示类型转换，在一个值或变量的前面，使用圆括号指定类型(type)，就可以将这个值或变量转为指定的类型，这叫做“类型指定”（casting） 可移植类型C语言的整数类型在不同计算机上占用字节宽度不同，头文件stdint.h创造了一些新的类型别名可用于控制准确的字节宽度。 指针指针是一个值，代表一个内存地址，它是指向某个内存地址的路标。字符*表示指针，通常跟在类型关键字后面 1int* intptr;//指针变量intptr，指向一个存放整数的内存地址 *可以放在变量名和类型关键字之间任何位置，个人习惯放在类型关键字后。 1int** foo;//指针可以指向一个指针，用**表示 *除了表示指针外还可以做为运算符，取出指针变量所指向的内存地址的值。 12int* intptr;printf(&quot;%d&quot;,*intptr); &amp;运算符用来取出变量所在内存地址。 1234int i = 1;int* ptrint = &amp;i; //指针变量初始化printf(&quot;%p&quot;,ptrint);printf(&quot;%d&quot;,*ptrint); 指针计算 指针与整数值的加减运算，指针与整数值进行运算表示指针的移动。 指针与指针的减法，指针相同类型的指针可以进行减法运算，返回两个指针的距离，高位地址减地位地址返回正值，低位地址减高位地址是负值。 指针与指针的比较运算，比较各自的内存地址大小，返回整数0或者1。 函数函数基础函数是一段可以重复执行的代码，可以接受不同的参数，完成对应操作 1234567//函数声明返回值类型 函数名(参数){ //注意C语言不支持函数重载，所以同一作用域的函数名不能相同,函数可以不包含参数，要用void关键字表示返回类型(直接为空也可以) 函数体; return;}//函数调用函数名(参数);//函数调用时参数个数必须和定义的参数个数相同 C语言规定main()是程序入口函数，所有程序必须包含一个main()函数 123int main(void) { return 0;} C语言规定返回值为0表示运行成功，返回其他非零整数表示运行失败，系统根据main()返回值作为整个程序的返回值确定程序是否运行成功。C语言会对main()函数默认添加返回值，对其他函数不会这样做。如果函数的参数是一个变量那么调用时，传入的是这个变量的值的拷贝，而不是变量本身，所以如果参数变量发生变化，最好作为返回值传出来，如果想要传入变量本身，可以传入变量的地址。切记函数不要返回内部变量的指针。 函数指针函数本身就是内存中的代码，C语言允许通过指针获取函数。 12345void func(int a) { return;}void (*func_ptr)(int) = &amp;func;//注意一定要加()，否则函数参数优先级高于*(*func_ptr)(10) //等同于func(10)，可以通过函数指针调用函数 C语言中规定，函数名本身就是指向函数的指针，通过函数名能够获取到函数地址，即func等同于&amp;func，因此对于任意函数有五种调用方式。 12345func();(*func)();(&amp;func)();(*func_ptr)();func_ptr(); 如果一个函数的参数或返回值也是函数，那么函数原型如下 1void func(int (*myfunc)(int), int ,int); 函数原型函数必须先声明后使用，由于程序从main()开始运行，导致其他函数都必须在main()函数之前声明，C语言提供的解决方案是，只要在程序开头给出函数原型，函数就可以先使用后声明。 12345678910void func(int);//函数声明时可以只声明参数类型，必须以分号结尾int main(void) { func(10); return 0;}void func(int) { return;} exit()exit()函数用来终止整个程序的运行，执行到该函数，程序就会结束，函数原型定义在头文件stdlib.h中。exit()函数可以向程序外部返回一个值，一般用两个常量作为参数。这两个常量也定义在stdlib.h中 1234567// 程序运行成功// 等同于 exit(0);exit(EXIT_SUCCESS);// 程序异常中止// 等同于 exit(1);exit(EXIT_FAILURE); 在main()函数中，exit()等价于return语句，其他函数使用exit()，就是终止整个程序运行，没有其他作用。C语言提供了一个atexit()函数，用来登记exit()执行时额外执行的函数，该函数原型定义在头文件stdlib.h 1int aiexit(void (*func)(void));//参数是一个函数指针，参数函数没有传参和返回值 exit()执行时会先调用atexit()注册的函数然后再终止程序。 函数说明符extern说明符extern可以用来引入其他文件定义的函数或者全局变量 123456789101112main.c#include stdio.hextern void func(void);int main(void){ extern int num; return 0; } func.hint num = 1;void func(void){ return;} static说明符每次调用函数时，函数内部变量都会重新初始化，不会保留上次运行的值，可通过static改变，表示变量只初始化一次，不需要每次调用时都初始化，即在两次调用之间保持不变。(注意static修饰的变量 初始化只能赋值常量，不能赋值变量)还可以用来修饰函数表示只能在当前文件中使用，如果没有该关键字，则其他文件也可以使用。 const说明符函数参数中的const说明符，表示函数内部不得修改该参数变量。 123void func(const int* p) {}//不能修改*p(指针指向的变量)的值void func(int* const p) {}//不能修改p(指针代表的内存地址)的值void func(const int* const p) {}//不能修改*p和p的值 可变参数有些函数的参数数量是不确定的，声明函数时可以用...表示可变数量的参数。 123456void func(int i, ...);//...表示可变数量的参数//头文件stdarg.h中定义了一些操作可变参数的宏va_list //一个数据类型，用来定义可变参数对象，必须在操作可变参数时，首先使用。va_start //一个函数，初始化可变参数对象，接收两个参数，一个是可变参数对象，一个是可变参数前的参数va_arg //一个函数，用来取出当前可变参数，每次调用后内部指针执行下一个可变参数，接受两个参数，一个是可变参数对象，一个是当前可变参数类型va_end //一个函数，用来清理可变参数对象 数组数组基础数组是一组相同类型的值，按照顺序储存在一起，通过在变量名后加方括号表示，方括号中是数组成员数量 123456int array[10]; //声明数组时必须声明数组的大小array[0] = 0; //通过引用数组成员进行赋值，数组从0开始到长度减一结束，注意如果越界访问数组，C语言中不会报错(代码编辑器会报错)int array[3] = {0,1,2}; //可以在声明是进行赋值，声明后就不可以通过{}赋值了int array[3] = {1,2}; //{}赋值时未赋值的成员自动初始化为0int array[3] = {[1] = 1，2}; //初始化时可以指定哪些位置有成员赋值，指定位置时可以不按照顺序赋值，指定位置赋值和顺序赋值可以结合使用。int array[] = {0, 1, 2}; //赋值时可以省略成员数量，这是按照赋值数量确定数组长度 sizeof运算符会返回数组字节长度，每个数组成员字节长度相同，因为可以获取数组长度 12int a[] = {1, 2, 3};int length = sizeof(a)/sizeof(a[0]); //数组长度 多维数组C语言允许声明多个维度的数组，有多少维度就有多少方括号 1234567int array[3][3];array[0][0] = 0; //同时指定两个维度引用成员变量int array[3][3] = { {1, 2, 3}, {4, 5, 6}}; //可以通过大括号进行赋值，也可以进行指定位置赋值int array[3][3] = {1, 2, 3, 4, 5, 6}; //多维数组也是线性存储，因此也可以单层大括号赋值 变长数组数组声明时，长度可以使用变量，当编译器需要运行代码时才知道长度的数组(即数组长度中有变量)，称为变长数组。 12int n;int array[n]; 数组的地址C语言中数组名等于数组起始地址，即指向数组第一个成员的指针。*和&amp;也可以用于数组数组名指向的地址不能更改，声明数组时，编译器自动为数组分配了内存地址，地址与数组名是绑定的，因此也不能将数组名赋值给另外一个数组名。 数组指针的加减法C语言中，数组名可以进行加减法运算，等同于在数组成员之间移动 1a[i] = *(a+i); 可以通过数组内两个成员变量相减求出之间的距离。 123456int array[9] = {[0] = 0, [8] = 8};int* p = array; //不能直接对数组名进行操作，因此要赋值pwhile (*p != 8) { p++;}int i = p - array; 数组的复制因为数组名是指针，复制数组不能直接简单的复制数组名 12345678910//方法一 让a和b指向同一个数组int* a;int b[3];a = b;//方法二 将所有数组成员进行一一赋值for (int i = 0; i &lt; length; i++) { a[i] = b[i];}//方法三 通过头文件string.h中的memcpy()函数memcpy(a, b, sizeof(b)); //将数组b的那段内存复制给a 作为函数的参数1234int sum_array(int a[], int length) {} //数组作为函数参数，一般会同时传入数组名和数组长度int sum_array(int a[][4], int length) {} //二维数组一般传入第一维的长度int sum_array(int n, int a[n]) {} //变长数组先传入长度变量int sum = sum_array((int []){0, 1, 2, 3}, 4); //可以将数组字面量作为参数传入函数 字符串字符串基础C语言没有单独的字符串类型，用char类型的数组表示。在字符串结尾C语言会自动添加一个全是二进制0的字节\\0，表示字符串结束，因此C语言不需要知道字符串的长度，读取到\\0停止即可，但是声明了n个成员的字符数组，只能容纳n-1个字符。 12&quot;hello&quot;//C语言规定双引号中的字符，自动视为字符数组char string[50] = &quot;how &quot;&quot;are &quot;&quot;you&quot;; //C语言支持合并多个字符串字面量，只要中间没有间隔或者只有空格 字符串变量可以声明成一个数组也可以声明成一个指针。 12char s[] = &quot;hello&quot;; //声明成数组，可以省略字符数组长度char* s = &quot;hello&quot;; //声明成指针 字符指针和字符数组的差别 指针指向的字符串在C语言内部被当作常量，不能修改字符串本身。系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的。声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。1const char* s = &quot;hello&quot;; //可以用const声明，保证无法修改 指针变量可以指向另一个字符串，字符数组不能。数组变量所在的地址无法改变，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。 字符串函数strlen()函数在头文件string.h中定义，返回字符串的字节长度，不包括\\0 1size_t strlen(const char* s); strcpy()字符串的复制，不能直接用赋值运算符，可以通过strcpy()函数将一个字符串的内容赋值给另一个字符串，在头文件string.h中定义 1strcpy(char dest[], const char source[]) //dest是要复制的字符串，需要确保第一个参数长度不小于第二个参数，也可以用于字符数组的赋值，注意第一个参数最好是数组，而不是字符指针 strncpy()与strcpy()用法一样，但是多个一个指定复制的最大字符数的参数，用于防止目标字符串越界。在头文件string.h中定义 1char* strncpy(char* dest, char* src, size_t n); //将会复制到最大字符数n结束，可用于复制部分字符 strcat()用于连接两个字符，将第二个字符串的副本添加到第一个字符串的末尾，在头文件string.h中定义 1char* strcat(char* s1, const char* s2); //需要确保第一个字符串的长度可以容纳第二个字符串，否会越界 strncat()用于连接两个字符，比strcat()添加了指定最大添加的字符，达到最大添加字符或者到达第一个字符末尾后，不在添加，在头文件string.h中定义。 1char* strncat(const char* dest, const char* src, size_t n); strcmp()用于比较两个字符内容，在头文件string.h中定义，字符串相同返回0，如果s1小于s2，返回值小于0，如果s1大于s2，返回值大于0。 1int strcmp(const char* s1, const char* s2); //只能比较字符串，不能比较字符 strncmp()可以比较到指定位置，比strcmp()多了指定比较字符数参数，在头文件string.h中定义，字符串相同返回0，如果s1小于s2，返回值小于0，如果s1大于s2，返回值大于0。 1int strncmp(const char* s1, const char* s2, size_t n); sprintf(),snprintf()sprintf()用于将数据写入字符串，返回值是写入变量的字符数量，遇到错误返回负值，定义在头文件stdio.h中 1int sprintf(char* s, const char* format, ...); 如果写入的字符串过长，超过了目标字符串的长度，sprintf()仍会写入，导致发生溢出，可以用snprintf()，多了一个控制写入字符不超过n-1的变量n，返回值是写入的字符数量，n足够大，返回值小于n，格式字符串的长度大于n，返回值会大于n，但实际上真正写入变量的还是n-1个字符。如果遇到错误，返回一个负值。返回值只有在非负并且小于n时，才能确认完整的格式字符串写入了变量。 1int snprintf(char*s, size_t n, const char* format, ...); 字符串数组可以通过二维字符数组实现字符串数组 123456789char weekdays[][10] = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;}; //第一维的长度，编译器可以自动计算，可以省略 数组的第二维，长度统一定为10，有点浪费空间，可以把数组的第二维，从字符数组改成字符指针。 123456789101112char* weekdays[] = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;}; //建议字符串数组声明方式for (int i = 0; i &lt; 7; i++) { printf(&quot;%s\\n&quot;, weekdays[i]);} //遍历字符串数组 内存管理内存管理基础C语言的内存管理分为两部分，一部分是系统管理，一部分是用户手动管理。 系统管理：主要是函数内部的局部变量，在函数运行时进入内存，函数运行后自动从内存卸载，这些变量存放的区域被称为”栈”，”栈”所在的内存是系统自动管理的。 用户手动管理，主要是全局变量，这些变量需要用户手动从内存释放，如果忘记释放就会一直占用内存直到程序退出，这种情况称为”内存泄漏”，这些变量所在区域被称为”堆”,”堆所在内存是用户手动管理的。 void指针C语言每块内存都有地址，通过指针变量可以获取指定地址的内存块，当系统请求内存时，有时不确定会有什么样的数据写入，C语言提供了void指针，只有内存块地址信息，没有类型信息，可以在使用到内存块时向编译器补充说明里面的数据类型。 123int x = 10;void* p = &amp;x; //整数指针转为 void 指针int*q = p; //void 指针转为整数指针 任一类型的指针都可以转为 void 指针， void 指针也可以转为任一类型的指针，由于不知道 void 指针指向什么类型的值，所以不能用*运算符取出它指向的值。 malloc()malloc()用于分配内存，函数向系统要求一段内存，系统在’堆’里分配一段连续内存，函数定义在头文件stdlib.h中 12void* malloc(size_t size); //非负整数作为参数，表示要分配的内存字节数，返回一个void指针，指向分配好的内存块，当内存分配失败时，返回常量NULLint* p = (int*) malloc(n*sizeof(int)); //可以用来创建动态数组 malloc()不会对所分配的内存进行初始化。 free()free()用于释放malloc()分配的内存，定义在头文件stdlib.h中 1void free(void* block) //参数是malloc()返回的内存地址 calloc()与函数malloc()相似，分配分类内存块，函数定义在头文件stdilb.h中 1void* calloc(size_t n, size_t size); //接受两个参数，一个是数据类型的值的数量，一个是数据类型的单位字节长度，返回值是一个void指针，分配失败返回NULL 函数会将所有分配的内存全部初始化为0，最后也需要使用free()释放。 realloc()用于修改已经分配的内存块的大小，返回一个指向新的内存块的指针，分配失败返回NULL，分配失败时原内存块数据不会改变，定义在头文件stdlib.h中 1void* realloc(void* block, size_t size); //接受两个参数，已经分配好的内存块指针block，内存块新大小size 新内存块小于原来地址，则丢弃超出部分，如果大于原来大小，不对新增部分进行初始化。realloc()第一个参数如果是NULL，表示新建一个指针，第二个参数如果是0，表示释放掉内存块 restrict 说明符声明指针变量时，可以使用restrict说明符，表示该内存区域只有当前指针一种访问方式，其他指针不能读写该内存，这种指针称为”受限指针” 1int* restrict p = malloc(sizeof(int)); memcpy()用于将一块内存拷贝到另一块内存，定义在头文件string.h中 1void* memcpy(void* restrict dest, void* restrict source, size_t n); //dest是目标地址，source是源地址，n是要拷贝的字节数，返回值是指向目标地址的指针 memmove()将一段内存数据复制到另一段内存，函数定义在string.h中，与memcpy()的主要区别是，允许目标区域与原区域有重叠，定义在头文件string.h 1void* memmove(void* dest, void* source, size_t n); memcmp()用来比较两个内存区域，定义在头文件string.h 12int memcmp(const void* s1, const void* s2,size_t n); //前两个参数是用来比较的指针，最后一个参数是比较的字节数 返回值是一个整数，按照字典顺序进行比较，如果两者相同，返回0；如果s1大于s2，返回大于0的整数；如果s1小于s2，返回小于0的整数。可以比较内部带有\\0的内存区域 struct 结构基础C语言内置数据类型不够用，因此需要强大的复合类型，可以通过struct关键字自定义复合数据类型。 123456789101112131415161718192021struct fraction { int numerator; int denominator;}; //定义一个数据类型 struct fraction f1; //声明数据类型，此时编译器分配内存f1.numerator = 22; f1.denominator = 7; //属性赋值struct fraction f2 = {22, 7} //声明变量时直接赋值，可以顺序不一致，但是要为每个值指定属性名，未被赋值的属性会被初始化为0f2.numerator = 23; //声明后可以修改变量值struct fraction { int numerator; int denominator;} f1 = {22, 7}, f2 = {22, 7}; //数据类型声明语句，变量声明语句，赋值都可以合并为同一个语句struct fraction* f1; //指针变量可以指向struct结构struct fraction f1[10]; //可以作为数组成员 struct结构占用的内存空间是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐，因此最好按照存储空间递增顺序定义struct结构体，节省一些空间。 struct 的复制可以通过赋值运算符=将struct的每个属性的值拷贝给另外一个struct变量，这时会生成一个全新的副本，系统会分配一块新的内存空间，大小与原来的变量相同。注意如果有指针变量则会两个指针指向同一个地址。 struct 指针将struct变量传入函数，函数内部得到的是原始值副本，执行完毕后，函数外部struct变量属性值没有变化，这时可以传入struct","link":"/2023/08/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"个人笔记","slug":"个人笔记","link":"/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"pages":[]}